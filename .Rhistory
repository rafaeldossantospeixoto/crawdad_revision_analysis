dfs[[1]] %>%
ggplot() +
geom_point(aes(x, y, color = celltype), size = .1) +
scale_color_manual(values = rainbow(3))
dfs[[7]] %>%
ggplot() +
geom_point(aes(x, y, color = celltype), size = .1) +
scale_color_manual(values = rainbow(3))
for (i in 1:length(dfs)) {
print(table(dfs[[i]]$celltype))
write.csv(dfs[[i]], paste0('simulating_data/densities/proportion_',
str_replace(100*proportions[[i]], '\\.', ''),
'.csv'))
}
library(crawdad)
library(tidyverse)
## similar to a real dataset (spleen)
## spleen is 3.5 x 3.5 mm, with 150k cells and structures of .5 mm
tissue_size <- 4 * 1e3 ## 5 mm or 5000 microns
circle_diameter <- 1e3
## number of cells is estimated based on sleen density
## spleen has 45k per 1 mm in size
number_of_cells <- 45 * tissue_size
centroids <- list(c(tissue_size/4, tissue_size/4),
c(tissue_size*3/4, tissue_size/4),
c(tissue_size*3/4, tissue_size*3/4),
c(tissue_size/4, tissue_size*3/4),
c(tissue_size/2, tissue_size/2))
simulate_symmetries <- function(tissue_size, number_of_cells, circle_diameter,
centroids) {
dfs <- list()
for (i in 1:length(centroids)) {
## define background
df <- crawdad:::simulate_background(size = number_of_cells, scale = tissue_size)
## simulate circle
x_center <- centroids[[i]]
y_center <- centroids[[i]]
radius <- circle_diameter/2
cells_circle <- rownames(df[((df$x-x_center)^2 + (df$y - y_center)^2 < radius^2),])
df[cells_circle, 'type'] <- 'B'
cells_type_c <- sample(cells_circle,
size = round(length(cells_circle) * .5), ## 50
replace = FALSE)
df[cells_type_c, 'type'] <- 'C'
colnames(df) <- c('x', 'y', 'celltype')
dfs[[i]] <- df
}
return(dfs)
}
dfs <- simulate_densities(tissue_size, number_of_cells, circle_diameter,
proportions)
dfs <- simulate_symmetries(tissue_size, number_of_cells, circle_diameter,
proportions)
simulate_symmetries <- function(tissue_size, number_of_cells, circle_diameter,
centroids) {
dfs <- list()
for (i in 1:length(centroids)) {
## define background
df <- crawdad:::simulate_background(size = number_of_cells, scale = tissue_size)
## simulate circle
x_center <- centroids[[i]][1]
y_center <- centroids[[i]][2]
radius <- circle_diameter/2
cells_circle <- rownames(df[((df$x-x_center)^2 + (df$y - y_center)^2 < radius^2),])
df[cells_circle, 'type'] <- 'B'
cells_type_c <- sample(cells_circle,
size = round(length(cells_circle) * .5), ## 50
replace = FALSE)
df[cells_type_c, 'type'] <- 'C'
colnames(df) <- c('x', 'y', 'celltype')
dfs[[i]] <- df
}
return(dfs)
}
dfs <- simulate_symmetries(tissue_size, number_of_cells, circle_diameter,
proportions)
i <- 1
centroids[[i]][1]
centroids[[i]][2]
centroids
# Set the total length of the list
total_length <- 5
# Create the list of vectors
result_list <- lapply(seq_len(total_length), function(x) {
rep(TRUE, times = total_length - x + 1)
})
# Print the result
print(result_list)
# Create the list of vectors
result_list <- lapply(seq_len(total_length), function(x) {
c(rep(TRUE, times = total_length - x + 1), rep(FALSE, times = x - 1))
})
# Print the result
print(result_list)
seq_len(number_of_dfs)
seq_len(5)
simulate_symmetries <- function(tissue_size, number_of_cells, circle_diameter,
centroids) {
number_of_dfs <- length(centroids)
## creates a list of Boolean vectors that will decide whether a circle should
## have both cell types or not
both_celltypes <- lapply(seq_len(number_of_dfs), function(x) {
c(rep(TRUE, times = total_length - x + 1), rep(FALSE, times = x - 1))
})
dfs <- list()
for (ndf in 1:number_of_dfs) {
## define background
df <- crawdad:::simulate_background(size = number_of_cells, scale = tissue_size)
for (ncd in 1:length(centroids)) {
## simulate circle
x_center <- centroids[[i]][1]
y_center <- centroids[[i]][2]
radius <- circle_diameter/2
cells_circle <- rownames(df[((df$x-x_center)^2 + (df$y - y_center)^2 < radius^2),])
df[cells_circle, 'type'] <- 'B'
if (both_celltypes) {
cells_type_c <- sample(cells_circle,
size = round(length(cells_circle) * .5), ## 50
replace = FALSE)
df[cells_type_c, 'type'] <- 'C'
}
}
colnames(df) <- c('x', 'y', 'celltype')
dfs[[i]] <- df
}
return(dfs)
}
dfs <- simulate_symmetries(tissue_size, number_of_cells, circle_diameter,
centroids)
simulate_symmetries <- function(tissue_size, number_of_cells, circle_diameter,
centroids) {
number_of_dfs <- length(centroids)
## creates a list of Boolean vectors that will decide whether a circle should
## have both cell types or not
both_celltypes <- lapply(seq_len(number_of_dfs), function(x) {
c(rep(TRUE, times = total_length - x + 1), rep(FALSE, times = x - 1))
})
dfs <- list()
for (ndf in 1:number_of_dfs) {
## define background
df <- crawdad:::simulate_background(size = number_of_cells, scale = tissue_size)
for (ncd in 1:length(centroids)) {
## simulate circle
x_center <- centroids[[i]][1]
y_center <- centroids[[i]][2]
radius <- circle_diameter/2
cells_circle <- rownames(df[((df$x-x_center)^2 + (df$y - y_center)^2 < radius^2),])
df[cells_circle, 'type'] <- 'B'
if (both_celltypes[[ndf]][ncd]) {
cells_type_c <- sample(cells_circle,
size = round(length(cells_circle) * .5), ## 50
replace = FALSE)
df[cells_type_c, 'type'] <- 'C'
}
}
colnames(df) <- c('x', 'y', 'celltype')
dfs[[i]] <- df
}
return(dfs)
}
dfs <- simulate_symmetries(tissue_size, number_of_cells, circle_diameter,
centroids)
dfs[[1]] %>%
ggplot() +
geom_point(aes(x, y, color = celltype), size = .1) +
scale_color_manual(values = rainbow(3))
dfs[[5]] %>%
ggplot() +
geom_point(aes(x, y, color = celltype), size = .1) +
scale_color_manual(values = rainbow(3))
length(dfs)
length(dfs[[1]])
simulate_symmetries <- function(tissue_size, number_of_cells, circle_diameter,
centroids) {
dfs <- list()
number_of_dfs <- length(centroids)
## creates a list of Boolean vectors that will decide whether a circle should
## have both cell types or not
both_celltypes <- lapply(seq_len(number_of_dfs), function(x) {
c(rep(TRUE, times = total_length - x + 1), rep(FALSE, times = x - 1))
})
for (ndf in 1:number_of_dfs) {
## define background
df <- crawdad:::simulate_background(size = number_of_cells, scale = tissue_size)
for (ncd in 1:length(centroids)) {
## simulate circle
x_center <- centroids[[i]][1]
y_center <- centroids[[i]][2]
radius <- circle_diameter/2
cells_circle <- rownames(df[((df$x-x_center)^2 + (df$y - y_center)^2 < radius^2),])
df[cells_circle, 'type'] <- 'B'
if (both_celltypes[[ndf]][ncd]) {
cells_type_c <- sample(cells_circle,
size = round(length(cells_circle) * .5), ## 50
replace = FALSE)
df[cells_type_c, 'type'] <- 'C'
}
}
colnames(df) <- c('x', 'y', 'celltype')
dfs[[ndf]] <- df
}
return(dfs)
}
dfs <- simulate_symmetries(tissue_size, number_of_cells, circle_diameter,
centroids)
dfs[[1]] %>%
ggplot() +
geom_point(aes(x, y, color = celltype), size = .1) +
scale_color_manual(values = rainbow(3))
dfs[[5]] %>%
ggplot() +
geom_point(aes(x, y, color = celltype), size = .1) +
scale_color_manual(values = rainbow(3))
simulate_symmetries <- function(tissue_size, number_of_cells, circle_diameter,
centroids) {
dfs <- list()
number_of_dfs <- length(centroids)
## creates a list of Boolean vectors that will decide whether a circle should
## have both cell types or not
both_celltypes <- lapply(seq_len(number_of_dfs), function(x) {
c(rep(TRUE, times = total_length - x + 1), rep(FALSE, times = x - 1))
})
for (ndf in 1:number_of_dfs) {
## define background
df <- crawdad:::simulate_background(size = number_of_cells, scale = tissue_size)
for (ncd in 1:length(centroids)) {
## simulate circle
x_center <- centroids[[ncd]][1]
y_center <- centroids[[ncd]][2]
radius <- circle_diameter/2
cells_circle <- rownames(df[((df$x-x_center)^2 + (df$y - y_center)^2 < radius^2),])
df[cells_circle, 'type'] <- 'B'
if (both_celltypes[[ndf]][ncd]) {
cells_type_c <- sample(cells_circle,
size = round(length(cells_circle) * .5), ## 50
replace = FALSE)
df[cells_type_c, 'type'] <- 'C'
}
}
colnames(df) <- c('x', 'y', 'celltype')
dfs[[ndf]] <- df
}
return(dfs)
}
dfs <- simulate_symmetries(tissue_size, number_of_cells, circle_diameter,
centroids)
dfs[[1]] %>%
ggplot() +
geom_point(aes(x, y, color = celltype), size = .1) +
scale_color_manual(values = rainbow(3))
dfs[[5]] %>%
ggplot() +
geom_point(aes(x, y, color = celltype), size = .1) +
scale_color_manual(values = rainbow(3))
dfs[[3]] %>%
ggplot() +
geom_point(aes(x, y, color = celltype), size = .1) +
scale_color_manual(values = rainbow(3))
dfs[[4]] %>%
ggplot() +
geom_point(aes(x, y, color = celltype), size = .1) +
scale_color_manual(values = rainbow(3))
dfs[[2]] %>%
ggplot() +
geom_point(aes(x, y, color = celltype), size = .1) +
scale_color_manual(values = rainbow(3))
0:(length(dfs)-1)
for (i in 0:(length(dfs)-1)) {
print(table(dfs[[i]]$celltype))
write.csv(dfs[[i]], paste0('simulating_data/symmetries/symmetry_',
str_replace(100*proportions[[i]], '\\.', ''),
'.csv'))
}
for (i in 0:(length(dfs)-1)) {
print(table(dfs[[i]]$celltype))
write.csv(dfs[[i]], paste0('simulating_data/symmetries/symmetry_',
i,
'.csv'))
}
for (i in 1:length(dfs))) {
for (i in 1:length(dfs)) {
print(table(dfs[[i]]$celltype))
write.csv(dfs[[i]], paste0('simulating_data/symmetries/symmetry_',
i-1, '.csv'))
}
library(crawdad)
library(tidyverse)
df <- read_csv('simulating_data/symmetries/symmetry_0.csv')
head(df)
df <- read_csv('simulating_data/symmetries/symmetry_0.csv', row.names = 1)
df <- read.csv('simulating_data/symmetries/symmetry_0.csv', row.names = 1)
head(df)
df %>%
ggplot() +
geom_point()
df %>%
ggplot() +
geom_point(aes(x, y, color = celltype))
dim(df)
df %>%
ggplot() +
geom_point(aes(x, y, color = celltype)) +
scale_color_manual(values = rainbow(3))
#' For a reference cell type and different neighborhood distances, plot the
#' proportion of each neigbor cell type inside the neighborhood of the reference
#' cell type at those distances.
#'
#' @param cells sf data.frame; as produced by crawdad::toSF function: cells with
#' cell types anotated in the celltypes column and point positions in the
#' geometry column
#' @param reference character; reference cell type to define neihborhood around
#' @param distances numeric vector; distances used to define the neighborhoods
#'
compareNeighborhoods <- function(cells, reference, distances) {
df_distances <- data.frame()
## parallelize this loop
for (distance in distances) {
## create a circle around each reference cell
buffer <- sf::st_buffer(cells[cells$celltypes == reference,], distance)
## merge the circles into a neighborhood (can take some time to compute)
neighborhood <- sf::st_union(buffer)
## calculate cells inside the neighborhood
neighbor_cells <- sf::st_intersection(cells, neighborhood)
## calculate proportions
proportions <- as.vector(round(100*table(neighbor_cells$celltypes)/table(cells$celltypes), 2))
names(proportions) <- names(round(100*table(neighbor_cells$celltypes)/table(cells$celltypes), 2))
## create a dataframe with this information
df_distance <- data.frame(celltypes = names(proportions),
proportions = proportions,
distances = distance)
df_distances <- rbind(df_distances, df_distance)
}
df_distances %>%
dplyr::filter(celltypes != reference) %>%
ggplot2::ggplot() +
ggplot2::geom_line(ggplot2::aes(x = distances, y = proportions,
color = celltypes)) +
ggplot2::scale_color_manual(values = grDevices::rainbow(length(unique(cells$celltypes)) - 1)) +
ggplot2::guides(color = ggplot2::guide_legend(override.aes = list(linewidth = 2))) +
ggplot2::theme_minimal()
}
#' For a reference cell type and different neighborhood distances, plot the
#' proportion of each neigbor cell type inside the neighborhood of the reference
#' cell type at those distances.
#'
#' @param cells sf data.frame; as produced by crawdad::toSF function: cells with
#' cell types anotated in the celltypes column and point positions in the
#' geometry column
#' @param reference character; reference cell type to define neihborhood around
#' @param distances numeric vector; distances used to define the neighborhoods
#'
compareNeighborhoods <- function(cells, reference, distances) {
df_distances <- data.frame()
## parallelize this loop
for (distance in distances) {
## create a circle around each reference cell
buffer <- sf::st_buffer(cells[cells$celltypes == reference,], distance)
## merge the circles into a neighborhood (can take some time to compute)
neighborhood <- sf::st_union(buffer)
## calculate cells inside the neighborhood
neighbor_cells <- sf::st_intersection(cells, neighborhood)
## calculate proportions
proportions <- as.vector(round(100*table(neighbor_cells$celltypes)/table(cells$celltypes), 2))
names(proportions) <- names(round(100*table(neighbor_cells$celltypes)/table(cells$celltypes), 2))
## create a dataframe with this information
df_distance <- data.frame(celltypes = names(proportions),
proportions = proportions,
distances = distance)
df_distances <- rbind(df_distances, df_distance)
}
df_distances %>%
dplyr::filter(celltypes != reference) %>%
ggplot2::ggplot() +
ggplot2::geom_line(ggplot2::aes(x = distances, y = proportions,
color = celltypes)) +
ggplot2::scale_color_manual(values = grDevices::rainbow(length(unique(cells$celltypes)) - 1)) +
ggplot2::guides(color = ggplot2::guide_legend(override.aes = list(linewidth = 2))) +
ggplot2::theme_minimal()
}
## Podoplanin
reference <- 'C'
distances <- c(25, 50, 75, 100, 150, 200, 300, 400, 500)
it <- Sys.time()
plt_distances <- compareNeighborhoods(cells, reference, distances)
Sys.time() - it
## convert dataframe to spatial points (SP)
cells <- crawdad::toSF(pos = pkhl[,c("x", "y")], celltypes = pkhl$celltypes)
## convert dataframe to spatial points (SP)
cells <- crawdad::toSF(pos = df[,c("x", "y")], celltypes = df$celltype)
## Podoplanin
reference <- 'C'
distances <- c(25, 50, 75, 100, 150, 200, 300, 400, 500)
it <- Sys.time()
plt_distances <- compareNeighborhoods(cells, reference, distances)
Sys.time() - it
## Time difference of 7.18728 mins
plt_distances
gc()
library(crawdad)
library(tidyverse)
# Load data ---------------------------------------------------------------
df <- read.csv('simulating_data/symmetries/symmetry_0.csv', row.names = 1)
dim(df)
head(df)
df %>%
ggplot() +
geom_point(aes(x, y, color = celltype)) +
scale_color_manual(values = rainbow(3))
## convert dataframe to spatial points (SP)
cells <- crawdad::toSF(pos = df[,c("x", "y")], celltypes = df$celltype)
list.files()
list.files('simulating_data/symmetries/')
lfs <- list.files('simulating_data/symmetries/')
lfs <- str_extract_all(lfs, "\\b\\w+\\.csv\\b")
lfs
lfs <- unlist(str_extract_all(lfs, "\\b\\w+\\.csv\\b"))
lfs <- list.files('simulating_data/symmetries/')
lfs <- unlist(str_extract_all(lfs, "\\b\\w+\\.csv\\b"))
lfs
teest <- list()
teest <- append(1)
teest <- append(teest, 1)
teest <- append(teest, 3)
teest
library(crawdad)
library(tidyverse)
# Get filenames -----------------------------------------------------------
lfs <- list.files('simulating_data/symmetries/')
lfs <- unlist(str_extract_all(lfs, "\\b\\w+\\.csv\\b"))
ncores <- 7
scales <- c(100, 200, 300, 400, 500, 600, 700, 800, 900, 1000)
dats <- list()
for (file_name in lfs) {
df <- read.csv(paste0('simulating_data/symmetries/', file_name),
row.names = 1)
cells <- crawdad::toSF(pos = df[,c("x", "y")], celltypes = df$celltype)
shuffle.list <- crawdad:::makeShuffledCells(cells,
scales = scales,
perms = 3,
ncores = ncores,
seed = 1,
verbose = TRUE)
results <- crawdad::findTrends(cells,
dist = 50,
shuffle.list = shuffle.list,
ncores = ncores,
verbose = TRUE,
returnMeans = FALSE)
dat <- crawdad::meltResultsList(results, withPerms = TRUE)
dats <- append(dats, dat)
}
## Time was 38.81 mins
saveRDS(results, 'simulating_data/symmetries/results/dats.RDS')
dat <- dats[[1]]
## calculate the zscore for the multiple-test correction
zsig <- correctZBonferroni(dat)
length(lfs)
names(dat)
names(dats)
dats <- list()
for (file_name in lfs) {
df <- read.csv(paste0('simulating_data/symmetries/', file_name),
row.names = 1)
cells <- crawdad::toSF(pos = df[,c("x", "y")], celltypes = df$celltype)
shuffle.list <- crawdad:::makeShuffledCells(cells,
scales = scales,
perms = 3,
ncores = ncores,
seed = 1,
verbose = TRUE)
results <- crawdad::findTrends(cells,
dist = 50,
shuffle.list = shuffle.list,
ncores = ncores,
verbose = TRUE,
returnMeans = FALSE)
dat <- crawdad::meltResultsList(results, withPerms = TRUE)
dats[[file_name]] <- dat
}
## Time was 38.81 mins
saveRDS(results, 'simulating_data/symmetries/results/dats.RDS')
dat <- dats[[1]]
## calculate the zscore for the multiple-test correction
zsig <- correctZBonferroni(dat)
## summary visualization
vizColocDotplot(dat, zsig.thresh = zsig, zscore.limit = 2*zsig) +
theme(axis.text.x = element_text(angle = 35, h = 0))
dat <- dats[[2]]
## calculate the zscore for the multiple-test correction
zsig <- correctZBonferroni(dat)
## summary visualization
vizColocDotplot(dat, zsig.thresh = zsig, zscore.limit = 2*zsig) +
theme(axis.text.x = element_text(angle = 35, h = 0))
dat <- dats[[2]]
## calculate the zscore for the multiple-test correction
zsig <- correctZBonferroni(dat)
## summary visualization
vizColocDotplot(dat, zsig.thresh = zsig, zscore.limit = 2*zsig) +
theme(axis.text.x = element_text(angle = 35, h = 0))
## Time was 38.81 mins
saveRDS(dats, 'simulating_data/symmetries/results/dats.RDS')
file <- lfs[1]
file_name <- lfs[1]
df <- read.csv(paste0('simulating_data/symmetries/', file_name),
row.names = 1)
df %>%
ggplot() +
geom_point(aes(x, y, color = celltype)) +
scale_color_manual(values = rainbow(3))
## Time was 38.81 mins
saveRDS(dats, 'simulating_data/symmetries/results/dats.RDS')
?na.omit
